struct SparseHamiltonian{T} <: AbstractSparseHamiltonian{T}
    op::LinearOperatorSparse{T}
    u_cache::SparseMatrixCSC{T,Int}
end

function SparseHamiltonian(funcs, mats)
    cache = spzeros(eltype(mats[1]), size(mats[1])...)
    operator = AffineOperatorSparse(funcs, mats)
    SparseHamiltonian(operator, cache)
end

function (h::SparseHamiltonian)(t::Real)
    fill!(h.u_cache, 0.0)
    h.op(h.u_cache, t)
    h.u_cache
end

function (h::SparseHamiltonian)(du, u, p::Real, t::Real)
    H = h(t)
    du .+= -1.0im*p*(H*u - u*H)
end


function p_copy(h::SparseHamiltonian)
    SparseHamiltonian(h.op, spzeros(eltype(h.u_cache), size(h.u_cache)...))
end

function eigen_decomp(h::AbstractSparseHamiltonian, t; level = 2, kwargs...)
    H = h(t)
    w, v = eigs(H; nev = level, which = :SR, kwargs...)
end

"""
    calculate_unitary(H, tf; kwargs...)

Calculate the unitary operator generated by Hamiltonian `H`. `H` is a callable object whose only argument is unitless time `` s = t / t_f ``. Keyword arguments are directly passed to [solvers](http://docs.juliadiffeq.org/latest/basics/common_solver_opts.html).
"""
function calculate_unitary(H, tf; kwargs...)
    u0 = Matrix{ComplexF64}(I, size(H(0.0)))
    function f(du, u, p, t)
        mul!(du, H(t), u)
        lmul!(-1.0im * p, du)
    end

    function f_jac(J, u, p, t)
        hmat = H(t)
        mul!(J, -1.0im * p, hmat)
    end

    ff = ODEFunction(f; jac = f_jac)
    prob = ODEProblem(ff, u0, (0.0, 1.0), tf)

    # currently stiff algorithm does not support complex type
    sol = solve(prob, alg_hints = [:nonstiff]; kwargs...)
end


"""
    solve_schrodinger(H, tf; rtol=1e-6, atol=1e-8)

Solve close system Schrodinger equation defined by Hamiltonian `H`. `H` is a callable object whose only argument is unitless time `` s = t / t_f ``. Keyword arguments are directly passed to [solvers](http://docs.juliadiffeq.org/latest/basics/common_solver_opts.html).
"""
function solve_schrodinger(H, u0, tf; kwargs...)
    function f(du, u, p, t)
        mul!(du, H(t), u)
        lmul!(-1.0im * p, du)
    end

    function f_jac(J, u, p, t)
        hmat = H(t)
        mul!(J, -1.0im * p, hmat)
    end

    ff = ODEFunction(f; jac = f_jac)
    prob = ODEProblem(ff, u0, (0.0, 1.0), tf)
    sol = solve(prob, alg_hints = [:nonstiff]; kwargs...)
end
