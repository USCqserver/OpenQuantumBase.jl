struct Hamiltonian{T<:Complex} <: AbstractHamiltonian{T}
    op::LinearOperator{T}
    u_cache::Matrix{T}
end

struct HamiltonianSparse{T} <: AbstractHamiltonian{T}
    op::LinearOperatorSparse{T}
    u_cache::SparseMatrixCSC{T, Int}
end

function (h::Hamiltonian)(t::Real)
    fill!(h.u_cache, 0.0)
    h.op(h.u_cache, t)
    h.u_cache
end

function (h::Hamiltonian)(du, u, t::Real)
    H = h(t)
    gemm!('N', 'N', -1.0im, H, u, 1.0+0.0im, du)
    gemm!('N', 'N', 1.0im, u, H, 1.0+0.0im, du)
end

function (h::HamiltonianSparse)(t::Real)
    fill!(h.u_cache, 0.0)
    h.op(h.u_cache, t)
    h.u_cache
end

function (h::HamiltonianSparse)(du, u, t::Real)
    H = h(t)
    axpy!(-1.0im, H*u, du)
    axpy!(1.0im, u*H, du)
end

function scale!(h::Union{Hamiltonian, HamiltonianSparse}, a::Real)
    h.op.m .*= a
end

function eigen_decomp(h::Hamiltonian, t; level=2)
    H = h(t)
    w, v = eigen!(Hermitian(H))
    w[1:level], v[:, 1:level]
end

function eigen_decomp(h::HamiltonianSparse, t; level=2, kwargs...)
    H = h(t)
    w, v = eigs(H; nev=level, which=:SR, kwargs...)
end

"""
    calculate_unitary(H, tf; rtol=1e-6, atol=1e-8)

Calculate the unitary operator generated by Hamiltonian `H`. `H` is a callable object whose only argument is unitless time `` s = t / t_f ``.
"""
function calculate_unitary(H, tf; kwargs...)
    u0 = Matrix{ComplexF64}(I, size(H(0.0)))
    function f(du, u, p, t)
        mul!(du, H(t), u)
        lmul!(-1.0im*p, du)
    end

    function f_jac(J, u, p, t)
        hmat = H(t)
        mul!(J, -1.0im*p, hmat)
    end

    ff = ODEFunction(f; jac=f_jac)
    prob = ODEProblem(ff, u0, (0.0,1.0), tf)

    # currently stiff algorithm does not support complex type
    sol = solve(prob, alg_hints=[:nonstiff]; kwargs...)
end
